var Module = typeof Module != "undefined" ? Module : {};
! function(e, t) {
	"object" == typeof exports && "object" == typeof module ? module.exports = t() :
		"function" == typeof define && define.amd ? define([], t) : "object" ==
		typeof exports ? exports.DecoderWorker = t() : e.DecoderWorker = t()
}("undefined" != typeof self ? self : this, () => (() => {
	null;
	var e = {
			809: (e, t, r) => {
				var s, i, o = new Promise(function(e) {
					i = e
				});
				r.g.onmessage = function(e) {
					o.then(function() {
						switch (e.data.command) {
							case "decode":
								s && s.decode(e.data.id, e.data.pages);
								break;
							case "done":
								s && (s.sendLastBuffer(e.data.id), r.g.close());
								break;
							case "init":
								s = new u(e.data, Module)
						}
					})
				};
				var u = function(e, t) {
					if (!t) throw new Error(
						"Module with exports required to initialize a decoder instance");
					this.mainReady = o, this.config = Object.assign({
							bufferLength: 4096,
							decoderSampleRate: 48e3,
							outputBufferSampleRate: 48e3,
							resampleQuality: 3
						}, e), this._opus_decoder_create = t._opus_decoder_create, this._opus_decoder_destroy =
						t._opus_decoder_destroy, this._speex_resampler_process_interleaved_float =
						t._speex_resampler_process_interleaved_float, this._speex_resampler_init =
						t._speex_resampler_init, this._speex_resampler_destroy = t._speex_resampler_destroy,
						this._opus_decode_float = t._opus_decode_float, this._free = t._free,
						this._malloc = t._malloc, this.HEAPU8 = t.HEAPU8, this.HEAP16 = t.HEAP16,
						this.HEAP32 = t.HEAP32, this.HEAPF32 = t.HEAPF32, this.outputBuffers = []
				};
				u.prototype.decode = function(e, t) {
						var r = new DataView(t.buffer);
						this.getPageBoundaries(r).map(function(s) {
							var i = r.getUint8(s + 5, !0),
								o = r.getUint32(s + 18, !0);
							if (this.initialized || (this.numberOfChannels = 1, this.init(),
									this.initialized = !0), o > 1) {
								for (var u = r.getUint8(s + 26, !0), f = s + 27 + u, n = 0; n < u; n++) {
									var h = r.getUint8(s + 27 + n, !0);
									if (this.decoderBuffer.set(t.subarray(f, f += h), this.decoderBufferIndex),
										this.decoderBufferIndex += h, h < 255) {
										var a = this._opus_decode_float(this.decoder, this.decoderBufferPointer,
											this.decoderBufferIndex, this.decoderOutputPointer, this.decoderOutputMaxLength,
											0);
										this.HEAP32[this.decoderOutputLengthPointer >> 2] = a;
										var d = Math.ceil(a * this.config.outputBufferSampleRate / this.config
											.decoderSampleRate);
										this.HEAP32[this.resampleOutputLengthPointer >> 2] = d, this._speex_resampler_process_interleaved_float(
											this.resampler, this.decoderOutputPointer, this.decoderOutputLengthPointer,
											this.resampleOutputBufferPointer, this.resampleOutputLengthPointer
										), this.sendToOutputBuffers(e, this.HEAPF32.subarray(this.resampleOutputBufferPointer >>
											2, (this.resampleOutputBufferPointer >> 2) + d * this.numberOfChannels
										)), this.decoderBufferIndex = 0
									}
								}
								4 & i && this.sendLastBuffer(e)
							}
						}, this)
					}, u.prototype.getPageBoundaries = function(e) {
						for (var t = [], r = 0; r < e.byteLength - 4; r++) 1399285583 == e.getUint32(
							r, !0) && t.push(r);
						return t
					}, u.prototype.init = function() {
						this.resetOutputBuffers(), this.initCodec(), this.initResampler()
					}, u.prototype.initCodec = function() {
						this.decoder && (this._opus_decoder_destroy(this.decoder), this._free(
								this.decoderBufferPointer), this._free(this.decoderOutputLengthPointer),
							this._free(this.decoderOutputPointer));
						var e = this._malloc(4);
						this.decoder = this._opus_decoder_create(this.config.decoderSampleRate,
								this.numberOfChannels, e), this._free(e), this.decoderBufferMaxLength =
							4e3, this.decoderBufferPointer = this._malloc(this.decoderBufferMaxLength),
							this.decoderBuffer = this.HEAPU8.subarray(this.decoderBufferPointer,
								this.decoderBufferPointer + this.decoderBufferMaxLength), this.decoderBufferIndex =
							0, this.decoderOutputLengthPointer = this._malloc(4), this.decoderOutputMaxLength =
							this.config.decoderSampleRate * this.numberOfChannels * 120 / 1e3,
							this.decoderOutputPointer = this._malloc(4 * this.decoderOutputMaxLength)
					}, u.prototype.initResampler = function() {
						this.resampler && (this._speex_resampler_destroy(this.resampler), this
							._free(this.resampleOutputLengthPointer), this._free(this.resampleOutputBufferPointer)
						);
						var e = this._malloc(4);
						this.resampler = this._speex_resampler_init(this.numberOfChannels,
								this.config.decoderSampleRate, this.config.outputBufferSampleRate,
								this.config.resampleQuality, e), this._free(e), this.resampleOutputLengthPointer =
							this._malloc(4), this.resampleOutputMaxLength = Math.ceil(this.decoderOutputMaxLength *
								this.config.outputBufferSampleRate / this.config.decoderSampleRate),
							this.resampleOutputBufferPointer = this._malloc(4 * this.resampleOutputMaxLength)
					}, u.prototype.resetOutputBuffers = function() {
						this.outputBuffers = [], this.outputBufferArrayBuffers = [], this.outputBufferIndex =
							0;
						for (var e = 0; e < this.numberOfChannels; e++) this.outputBuffers.push(
								new Float32Array(this.config.bufferLength)), this.outputBufferArrayBuffers
							.push(this.outputBuffers[e].buffer)
					}, u.prototype.sendLastBuffer = function(e) {
						this.sendToOutputBuffers(e, new Float32Array((this.config.bufferLength -
							this.outputBufferIndex) * this.numberOfChannels)), r.g.postMessage(
							null)
					}, u.prototype.sendToOutputBuffers = function(e, t) {
						for (var s = 0, i = t.length / this.numberOfChannels; s < i;) {
							var o = Math.min(i - s, this.config.bufferLength - this.outputBufferIndex);
							if (1 === this.numberOfChannels) this.outputBuffers[0].set(t.subarray(
								s, s + o), this.outputBufferIndex);
							else
								for (var u = 0; u < o; u++) this.outputBuffers.forEach(function(e, r) {
									e[this.outputBufferIndex + u] = t[(s + u) * this.numberOfChannels +
										r]
								}, this);
							s += o, this.outputBufferIndex += o, this.outputBufferIndex == this.config
								.bufferLength && (this.outputBuffers.push(e), r.g.postMessage(this.outputBuffers,
									this.outputBufferArrayBuffers), this.resetOutputBuffers())
						}
					}, Module || (Module = {}), Module.mainReady = o, Module.OggOpusDecoder =
					u, Module.onRuntimeInitialized = i, e.exports = Module
			}
		},
		t = {};

	function r(s) {
		var i = t[s];
		if (void 0 !== i) return i.exports;
		var o = t[s] = {
			exports: {}
		};
		return e[s](o, o.exports, r), o.exports
	}
	return r.g = function() {
		if ("object" == typeof globalThis) return globalThis;
		try {
			return this || new Function("return this")()
		} catch (e) {
			if ("object" == typeof window) return window
		}
	}(), r(809)
})());
var moduleOverrides = Object.assign({}, Module);
var arguments_ = [];
var thisProgram = "./this.program";
var quit_ = (status, toThrow) => {
	throw toThrow
};
var ENVIRONMENT_IS_WEB = typeof window == "object";
var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions ==
	"object" && typeof process.versions.node == "string";
var scriptDirectory = "";

function locateFile(path) {
	if (Module["locateFile"]) {
		return Module["locateFile"](path, scriptDirectory)
	}
	return scriptDirectory + path
}
var read_, readAsync, readBinary, setWindowTitle;

function logExceptionOnExit(e) {
	if (e instanceof ExitStatus) return;
	let toLog = e;
	err("exiting due to exception: " + toLog)
}
var fs;
var nodePath;
var requireNodeFS;
if (ENVIRONMENT_IS_NODE) {
	if (ENVIRONMENT_IS_WORKER) {
		scriptDirectory = require("path").dirname(scriptDirectory) + "/"
	} else {
		scriptDirectory = __dirname + "/"
	}
	requireNodeFS = (() => {
		if (!nodePath) {
			fs = require("fs");
			nodePath = require("path")
		}
	});
	read_ = function shell_read(filename, binary) {
		requireNodeFS();
		filename = nodePath["normalize"](filename);
		return fs.readFileSync(filename, binary ? undefined : "utf8")
	};
	readBinary = (filename => {
		var ret = read_(filename, true);
		if (!ret.buffer) {
			ret = new Uint8Array(ret)
		}
		return ret
	});
	readAsync = ((filename, onload, onerror) => {
		requireNodeFS();
		filename = nodePath["normalize"](filename);
		fs.readFile(filename, function(err, data) {
			if (err) onerror(err);
			else onload(data.buffer)
		})
	});
	if (process["argv"].length > 1) {
		thisProgram = process["argv"][1].replace(/\\/g, "/")
	}
	arguments_ = process["argv"].slice(2);
	if (typeof module != "undefined") {
		module["exports"] = Module
	}
	process["on"]("uncaughtException", function(ex) {
		if (!(ex instanceof ExitStatus)) {
			throw ex
		}
	});
	process["on"]("unhandledRejection", function(reason) {
		throw reason
	});
	quit_ = ((status, toThrow) => {
		if (keepRuntimeAlive()) {
			process["exitCode"] = status;
			throw toThrow
		}
		logExceptionOnExit(toThrow);
		process["exit"](status)
	});
	Module["inspect"] = function() {
		return "[Emscripten Module object]"
	}
} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
	if (ENVIRONMENT_IS_WORKER) {
		scriptDirectory = self.location.href
	} else if (typeof document != "undefined" && document.currentScript) {
		scriptDirectory = document.currentScript.src
	}
	if (scriptDirectory.indexOf("blob:") !== 0) {
		scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/,
			"").lastIndexOf("/") + 1)
	} else {
		scriptDirectory = ""
	} {
		read_ = (url => {
			var xhr = new XMLHttpRequest;
			xhr.open("GET", url, false);
			xhr.send(null);
			return xhr.responseText
		});
		if (ENVIRONMENT_IS_WORKER) {
			readBinary = (url => {
				var xhr = new XMLHttpRequest;
				xhr.open("GET", url, false);
				xhr.responseType = "arraybuffer";
				xhr.send(null);
				return new Uint8Array(xhr.response)
			})
		}
		readAsync = ((url, onload, onerror) => {
			var xhr = new XMLHttpRequest;
			xhr.open("GET", url, true);
			xhr.responseType = "arraybuffer";
			xhr.onload = (() => {
				if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
					onload(xhr.response);
					return
				}
				onerror()
			});
			xhr.onerror = onerror;
			xhr.send(null)
		})
	}
	setWindowTitle = (title => document.title = title)
} else {}
var out = Module["print"] || console.log.bind(console);
var err = Module["printErr"] || console.warn.bind(console);
Object.assign(Module, moduleOverrides);
moduleOverrides = null;
if (Module["arguments"]) arguments_ = Module["arguments"];
if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
if (Module["quit"]) quit_ = Module["quit"];
var wasmBinary;
if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
var noExitRuntime = Module["noExitRuntime"] || true;
if (typeof WebAssembly != "object") {
	abort("no native wasm support detected")
}
var wasmMemory;
var ABORT = false;
var EXITSTATUS;
var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") :
	undefined;

function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
	var endIdx = idx + maxBytesToRead;
	var endPtr = idx;
	while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
	if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
		return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr))
	} else {
		var str = "";
		while (idx < endPtr) {
			var u0 = heapOrArray[idx++];
			if (!(u0 & 128)) {
				str += String.fromCharCode(u0);
				continue
			}
			var u1 = heapOrArray[idx++] & 63;
			if ((u0 & 224) == 192) {
				str += String.fromCharCode((u0 & 31) << 6 | u1);
				continue
			}
			var u2 = heapOrArray[idx++] & 63;
			if ((u0 & 240) == 224) {
				u0 = (u0 & 15) << 12 | u1 << 6 | u2
			} else {
				u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63
			}
			if (u0 < 65536) {
				str += String.fromCharCode(u0)
			} else {
				var ch = u0 - 65536;
				str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)
			}
		}
	}
	return str
}

function UTF8ToString(ptr, maxBytesToRead) {
	return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : ""
}
var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

function updateGlobalBufferAndViews(buf) {
	buffer = buf;
	Module["HEAP8"] = HEAP8 = new Int8Array(buf);
	Module["HEAP16"] = HEAP16 = new Int16Array(buf);
	Module["HEAP32"] = HEAP32 = new Int32Array(buf);
	Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
	Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
	Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
	Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
	Module["HEAPF64"] = HEAPF64 = new Float64Array(buf)
}
var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
var wasmTable;
var __ATPRERUN__ = [];
var __ATINIT__ = [];
var __ATPOSTRUN__ = [];
var runtimeInitialized = false;

function keepRuntimeAlive() {
	return noExitRuntime
}

function preRun() {
	if (Module["preRun"]) {
		if (typeof Module["preRun"] == "function") Module["preRun"] = [Module[
			"preRun"]];
		while (Module["preRun"].length) {
			addOnPreRun(Module["preRun"].shift())
		}
	}
	callRuntimeCallbacks(__ATPRERUN__)
}

function initRuntime() {
	runtimeInitialized = true;
	callRuntimeCallbacks(__ATINIT__)
}

function postRun() {
	if (Module["postRun"]) {
		if (typeof Module["postRun"] == "function") Module["postRun"] = [Module[
			"postRun"]];
		while (Module["postRun"].length) {
			addOnPostRun(Module["postRun"].shift())
		}
	}
	callRuntimeCallbacks(__ATPOSTRUN__)
}

function addOnPreRun(cb) {
	__ATPRERUN__.unshift(cb)
}

function addOnInit(cb) {
	__ATINIT__.unshift(cb)
}

function addOnPostRun(cb) {
	__ATPOSTRUN__.unshift(cb)
}
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null;

function addRunDependency(id) {
	runDependencies++;
	if (Module["monitorRunDependencies"]) {
		Module["monitorRunDependencies"](runDependencies)
	}
}

function removeRunDependency(id) {
	runDependencies--;
	if (Module["monitorRunDependencies"]) {
		Module["monitorRunDependencies"](runDependencies)
	}
	if (runDependencies == 0) {
		if (runDependencyWatcher !== null) {
			clearInterval(runDependencyWatcher);
			runDependencyWatcher = null
		}
		if (dependenciesFulfilled) {
			var callback = dependenciesFulfilled;
			dependenciesFulfilled = null;
			callback()
		}
	}
}
Module["preloadedImages"] = {};
Module["preloadedAudios"] = {};

function abort(what) {
	{
		if (Module["onAbort"]) {
			Module["onAbort"](what)
		}
	}
	what = "Aborted(" + what + ")";
	err(what);
	ABORT = true;
	EXITSTATUS = 1;
	what += ". Build with -s ASSERTIONS=1 for more info.";
	var e = new WebAssembly.RuntimeError(what);
	throw e
}
var dataURIPrefix = "data:application/octet-stream;base64,";

function isDataURI(filename) {
	return filename.startsWith(dataURIPrefix)
}

function isFileURI(filename) {
	return filename.startsWith("file://")
}
var wasmBinaryFile;
wasmBinaryFile = "decoderWorker.min.wasm";
if (!isDataURI(wasmBinaryFile)) {
	wasmBinaryFile = locateFile(wasmBinaryFile)
}

function getBinary(file) {
	try {
		if (file == wasmBinaryFile && wasmBinary) {
			return new Uint8Array(wasmBinary)
		}
		if (readBinary) {
			return readBinary(file)
		} else {
			throw "both async and sync fetching of the wasm failed"
		}
	} catch (err) {
		abort(err)
	}
}

function getBinaryPromise() {
	if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
		if (typeof fetch == "function" && !isFileURI(wasmBinaryFile)) {
			return fetch(wasmBinaryFile, {
				credentials: "same-origin"
			}).then(function(response) {
				if (!response["ok"]) {
					throw "failed to load wasm binary file at '" + wasmBinaryFile + "'"
				}
				return response["arrayBuffer"]()
			}).catch(function() {
				return getBinary(wasmBinaryFile)
			})
		} else {
			if (readAsync) {
				return new Promise(function(resolve, reject) {
					readAsync(wasmBinaryFile, function(response) {
						resolve(new Uint8Array(response))
					}, reject)
				})
			}
		}
	}
	return Promise.resolve().then(function() {
		return getBinary(wasmBinaryFile)
	})
}

function createWasm() {
	var info = {
		"a": asmLibraryArg
	};

	function receiveInstance(instance, module) {
		var exports = instance.exports;
		Module["asm"] = exports;
		wasmMemory = Module["asm"]["g"];
		updateGlobalBufferAndViews(wasmMemory.buffer);
		wasmTable = Module["asm"]["y"];
		addOnInit(Module["asm"]["h"]);
		removeRunDependency("wasm-instantiate")
	}
	addRunDependency("wasm-instantiate");

	function receiveInstantiationResult(result) {
		receiveInstance(result["instance"])
	}

	function instantiateArrayBuffer(receiver) {
		return getBinaryPromise().then(function(binary) {
			return WebAssembly.instantiate(binary, info)
		}).then(function(instance) {
			return instance
		}).then(receiver, function(reason) {
			err("failed to asynchronously prepare wasm: " + reason);
			abort(reason)
		})
	}

	function instantiateAsync() {
		if (!wasmBinary && typeof WebAssembly.instantiateStreaming == "function" && !
			isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch ==
			"function") {
			return fetch(wasmBinaryFile, {
				credentials: "same-origin"
			}).then(function(response) {
				var result = WebAssembly.instantiateStreaming(response, info);
				return result.then(receiveInstantiationResult, function(reason) {
					err("wasm streaming compile failed: " + reason);
					err("falling back to ArrayBuffer instantiation");
					return instantiateArrayBuffer(receiveInstantiationResult)
				})
			})
		} else {
			return instantiateArrayBuffer(receiveInstantiationResult)
		}
	}
	if (Module["instantiateWasm"]) {
		try {
			var exports = Module["instantiateWasm"](info, receiveInstance);
			return exports
		} catch (e) {
			err("Module.instantiateWasm callback failed with error: " + e);
			return false
		}
	}
	instantiateAsync();
	return {}
}

function callRuntimeCallbacks(callbacks) {
	while (callbacks.length > 0) {
		var callback = callbacks.shift();
		if (typeof callback == "function") {
			callback(Module);
			continue
		}
		var func = callback.func;
		if (typeof func == "number") {
			if (callback.arg === undefined) {
				getWasmTableEntry(func)()
			} else {
				getWasmTableEntry(func)(callback.arg)
			}
		} else {
			func(callback.arg === undefined ? null : callback.arg)
		}
	}
}
var wasmTableMirror = [];

function getWasmTableEntry(funcPtr) {
	var func = wasmTableMirror[funcPtr];
	if (!func) {
		if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
		wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr)
	}
	return func
}

function _abort() {
	abort("")
}

function _emscripten_memcpy_big(dest, src, num) {
	HEAPU8.copyWithin(dest, src, src + num)
}

function abortOnCannotGrowMemory(requestedSize) {
	abort("OOM")
}

function _emscripten_resize_heap(requestedSize) {
	var oldSize = HEAPU8.length;
	requestedSize = requestedSize >>> 0;
	abortOnCannotGrowMemory(requestedSize)
}
var SYSCALLS = {
	buffers: [null, [],
		[]
	],
	printChar: function(stream, curr) {
		var buffer = SYSCALLS.buffers[stream];
		if (curr === 0 || curr === 10) {
			(stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
			buffer.length = 0
		} else {
			buffer.push(curr)
		}
	},
	varargs: undefined,
	get: function() {
		SYSCALLS.varargs += 4;
		var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
		return ret
	},
	getStr: function(ptr) {
		var ret = UTF8ToString(ptr);
		return ret
	},
	get64: function(low, high) {
		return low
	}
};

function _fd_close(fd) {
	return 0
}

function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}

function _fd_write(fd, iov, iovcnt, pnum) {
	var num = 0;
	for (var i = 0; i < iovcnt; i++) {
		var ptr = HEAP32[iov >> 2];
		var len = HEAP32[iov + 4 >> 2];
		iov += 8;
		for (var j = 0; j < len; j++) {
			SYSCALLS.printChar(fd, HEAPU8[ptr + j])
		}
		num += len
	}
	HEAP32[pnum >> 2] = num;
	return 0
}
var asmLibraryArg = {
	"c": _abort,
	"e": _emscripten_memcpy_big,
	"f": _emscripten_resize_heap,
	"d": _fd_close,
	"b": _fd_seek,
	"a": _fd_write
};
var asm = createWasm();
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
	return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["h"])
		.apply(null, arguments)
};
var _opus_decoder_create = Module["_opus_decoder_create"] = function() {
	return (_opus_decoder_create = Module["_opus_decoder_create"] = Module["asm"]
		["i"]).apply(null, arguments)
};
var _opus_decode_float = Module["_opus_decode_float"] = function() {
	return (_opus_decode_float = Module["_opus_decode_float"] = Module["asm"]["j"])
		.apply(null, arguments)
};
var _opus_decoder_destroy = Module["_opus_decoder_destroy"] = function() {
	return (_opus_decoder_destroy = Module["_opus_decoder_destroy"] = Module[
		"asm"]["k"]).apply(null, arguments)
};
var _speex_preprocess_state_init = Module["_speex_preprocess_state_init"] =
	function() {
		return (_speex_preprocess_state_init = Module["_speex_preprocess_state_init"] =
			Module["asm"]["l"]).apply(null, arguments)
	};
var _speex_preprocess_state_destroy = Module["_speex_preprocess_state_destroy"] =
	function() {
		return (_speex_preprocess_state_destroy = Module[
			"_speex_preprocess_state_destroy"] = Module["asm"]["m"]).apply(null,
			arguments)
	};
var _speex_preprocess_run = Module["_speex_preprocess_run"] = function() {
	return (_speex_preprocess_run = Module["_speex_preprocess_run"] = Module[
		"asm"]["n"]).apply(null, arguments)
};
var _speex_preprocess_ctl = Module["_speex_preprocess_ctl"] = function() {
	return (_speex_preprocess_ctl = Module["_speex_preprocess_ctl"] = Module[
		"asm"]["o"]).apply(null, arguments)
};
var _speex_echo_state_init = Module["_speex_echo_state_init"] = function() {
	return (_speex_echo_state_init = Module["_speex_echo_state_init"] = Module[
		"asm"]["p"]).apply(null, arguments)
};
var _speex_echo_state_destroy = Module["_speex_echo_state_destroy"] = function() {
	return (_speex_echo_state_destroy = Module["_speex_echo_state_destroy"] =
		Module["asm"]["q"]).apply(null, arguments)
};
var _speex_echo_cancellation = Module["_speex_echo_cancellation"] = function() {
	return (_speex_echo_cancellation = Module["_speex_echo_cancellation"] =
		Module["asm"]["r"]).apply(null, arguments)
};
var _speex_echo_ctl = Module["_speex_echo_ctl"] = function() {
	return (_speex_echo_ctl = Module["_speex_echo_ctl"] = Module["asm"]["s"]).apply(
		null, arguments)
};
var _speex_resampler_init = Module["_speex_resampler_init"] = function() {
	return (_speex_resampler_init = Module["_speex_resampler_init"] = Module[
		"asm"]["t"]).apply(null, arguments)
};
var _speex_resampler_destroy = Module["_speex_resampler_destroy"] = function() {
	return (_speex_resampler_destroy = Module["_speex_resampler_destroy"] =
		Module["asm"]["u"]).apply(null, arguments)
};
var _speex_resampler_process_interleaved_float = Module[
	"_speex_resampler_process_interleaved_float"] = function() {
	return (_speex_resampler_process_interleaved_float = Module[
		"_speex_resampler_process_interleaved_float"] = Module["asm"]["v"]).apply(
		null, arguments)
};
var _malloc = Module["_malloc"] = function() {
	return (_malloc = Module["_malloc"] = Module["asm"]["w"]).apply(null,
		arguments)
};
var _free = Module["_free"] = function() {
	return (_free = Module["_free"] = Module["asm"]["x"]).apply(null, arguments)
};
var calledRun;

function ExitStatus(status) {
	this.name = "ExitStatus";
	this.message = "Program terminated with exit(" + status + ")";
	this.status = status
}
dependenciesFulfilled = function runCaller() {
	if (!calledRun) run();
	if (!calledRun) dependenciesFulfilled = runCaller
};

function run(args) {
	args = args || arguments_;
	if (runDependencies > 0) {
		return
	}
	preRun();
	if (runDependencies > 0) {
		return
	}

	function doRun() {
		if (calledRun) return;
		calledRun = true;
		Module["calledRun"] = true;
		if (ABORT) return;
		initRuntime();
		if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
		postRun()
	}
	if (Module["setStatus"]) {
		Module["setStatus"]("Running...");
		setTimeout(function() {
			setTimeout(function() {
				Module["setStatus"]("")
			}, 1);
			doRun()
		}, 1)
	} else {
		doRun()
	}
}
Module["run"] = run;
if (Module["preInit"]) {
	if (typeof Module["preInit"] == "function") Module["preInit"] = [Module[
		"preInit"]];
	while (Module["preInit"].length > 0) {
		Module["preInit"].pop()()
	}
}
run();
