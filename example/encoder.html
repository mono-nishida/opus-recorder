<!DOCTYPE html>

<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Ogg Opus Encoder Example</title>
	<script src="dist/recorder.min.js"></script>
	<style type='text/css'>
	ul { list-style: none; }
	    li { margin: 10px; }
	    audio { display: block; }
	</style>
</head>

<body>

	<h2>Options</h2>

	<div>
		<label>monitorGain</label>
		<input id="monitorGain" type="number" value="0" />
	</div>

	<div>
		<label>recordingGain</label>
		<input id="recordingGain" type="number" value="1" />
	</div>

	<div>
		<label>numberOfChannels</label>
		<input id="numberOfChannels" type="number" value="1" />
	</div>

	<div>
		<label>encoderSampleRate</label>
		<input id="encoderSampleRate" type="number" value="48000" />
	</div>

	<div>
		<label>encoderBitRate</label>
		<input id="encoderBitRate" type="number" value="32000" />
	</div>

	<div>
		<label>encoderApplication</label>
		<input id="encoderApplication" type="number" value="2049" />
	</div>

	<div>
		<label>encoderComplexity</label>
		<input id="encoderComplexity" type="number" value="3" />
	</div>

	<div>
		<button id="init">Init recorder with options</button>
	</div>

	<button id="start" disabled>Start</button>
	<button id="closeButton" disabled>Close</button>

	<h2>Decode Data</h2>
	<pre id="log"></pre>

	<script src="/socket.io/socket.io.js"></script>
	<script src="https://code.jquery.com/jquery-1.11.1.js"></script>
	<script>
	let isfirst = true;

	function screenLogger(text, data) {
		log.innerHTML += "\n" + text + " " + (data || '');
	}

	function buf2hex(buffer) { // buffer is an ArrayBuffer
		return [...new Uint8Array(buffer)]
			.map(x => x.toString(16).padStart(2, '0'))
			.join('');
	}

	if (!Recorder.isRecordingSupported()) {
		screenLogger("Recording features are not supported in your browser.");
	} else {
		init.addEventListener("click", function() {
			init.disabled = true;
			start.disabled = false;
			monitorGain.disabled = true;
			recordingGain.disabled = true;
			numberOfChannels.disabled = true;
			encoderBitRate.disabled = true;
			encoderSampleRate.disabled = true;
			closeButton.disabled = false;
			encoderApplication.disabled = true;
			encoderComplexity.disabled = true;

			let options = {
				monitorGain: parseInt(monitorGain.value, 10),
				recordingGain: parseInt(recordingGain.value, 10),
				numberOfChannels: parseInt(numberOfChannels.value, 10),
				encoderSampleRate: parseInt(encoderSampleRate.value, 10),
				encoderPath: "../dist/encoderWorker.min.js"
			};

			if (encoderBitRate.value) {
				Object.assign(options, {
					encoderBitRate: parseInt(encoderBitRate.value, 10)
				});
			}

			if (encoderApplication.value) {
				Object.assign(options, {
					encoderApplication: parseInt(encoderApplication.value, 10)
				});
			}

			if (encoderComplexity.value) {
				Object.assign(options, {
					encoderComplexity: parseInt(encoderComplexity.value, 3)
				});
			}

			let recorder = new Recorder(options);

			let recorderStart = function() {
				recorder.start().catch(function(e) {
					screenLogger('Error encountered:', e.message);
				});
			};
			let recorderClose = function() {
				screenLogger('Recorder is closed');
				recorder.close();
				init.disabled = false;

				start.disabled = true;
				closeButton.disabled = true;

				monitorGain.disabled = false;
				recordingGain.disabled = false;
				numberOfChannels.disabled = false;
				encoderBitRate.disabled = false;
				encoderSampleRate.disabled = false
				encoderApplication.disabled = false;
				encoderComplexity.disabled = false;

				start.removeEventListener("click", recorderStart);
				closeButton.removeEventListener("click", recorderClose);
			}

			start.addEventListener("click", recorderStart);
			closeButton.addEventListener("click", recorderClose);

			recorder.onstart = function(e) {
				screenLogger('Recorder is started');
			};

			let decoderWorker = new Worker('../dist/decoderWorker.min.js');
			let desiredSampleRate = parseInt(encoderSampleRate.value, 10);
			decoderWorker.postMessage({
				command: 'init',
				decoderSampleRate: desiredSampleRate,
				outputBufferSampleRate: desiredSampleRate
			});

			let socket = io();
			recorder.ondataavailable = function(typedArray) {
				if (typedArray !== undefined) {
					socket.emit('voice', typedArray);
				} else {
					screenLogger("---------");
				}
			};

			socket.on('voice', function(obj) {
				let receivedArray = new Uint8Array(Object.values(obj));
				screenLogger(buf2hex(receivedArray));
				decoderWorker.postMessage({
					command: 'decode',
					pages: receivedArray
				}, [receivedArray.buffer]);
			});

			decoderWorker.onmessage = function(e) {
				// null means decoder is finished
				if (e.data === null) {
					decoderWorker.postMessage({
						command: 'done'
					});
				} else {
					play(e.data);
				}
			};

		});


	}

	let AudioContext = window.AudioContext || window.webkitAudioContext;
	let audioCtx = new AudioContext();

	function play(waves) {
		let waveData = waves[0];
		let node = audioCtx.createBufferSource();
		let buffer = audioCtx.createBuffer(1, waveData.length, encoderSampleRate.value);
		let data = buffer.getChannelData(0);
		for (let i = 0; i < waveData.length; i++) {
			data[i] = waveData[i];
		}
		node.buffer = buffer;
		node.loop = false;
		node.connect(audioCtx.destination);
		node.start(0);
	};

	</script>
</body>

</html>
